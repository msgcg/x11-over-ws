Отлично — ты сформулировал точную цель. Ниже — **переработанный, готовый к имплементации план для умного IDE**, с конкретными файлами, протоколом, технологиями (Python на сервере), инструкциями по запуску, задачами/ветками/issue’ами и краткими примерами кода. Всё ориентировано на то, чтобы:
Тут помечено то что я делаю с проектом. при помощи вебхука(использую гитхаб и порт 5000, ключ хранится в переменной окружения сервера, файл вебхука используется в виде службы и его нельзя менять, менять можно deploy.py) и скелета развертывателя мой сервер по адресу oneserver.servehttp.com и 193.46.218.146 может автоматически развертывать изменения в проекте. давай закончим проект чтоб он работал полностью. Я работаю с клиентского пк, так что в его терминале ничего вводить не надо, зато мои коммиты мгновенно деплоятся на удаленном сервере. НЕ ВЫПОЛНЯЙ НИКАКИХ КОМАНД ТЕРМИНАЛА, ПРОСТО ГОВОРИ МНЕ КАКИЕ ИЗ НИХ НАДО НА СЕРВЕРЕ А КАКие НА КЛИЕНТЕ. проверь все файлы, даже если в плане они не описаны, могут присутствовать
* Сервер **не рендерил пиксели** — он только форвардит *сырные* X11-байты (но сжатые).
* Клиент = сайт, который загружается из `public/` на сервере и в браузере полностью интерпретирует X11-байты и рисует (Canvas/WebGL).
* Серверная реализация — **Python** (asyncio, websockets), лёгкий, однострочный запуск / systemd.
* Транспорт — WebSocket (binary frames) + per-frame zlib compression (совместимо с браузером через pako).

# 1. Короткая спецификация транспортного протокола (чтобы IDE понимал формат)

Мы передаём **сырные X11-байты** между X-клиентом (на сервере) и браузером (в роли X-сервера). Но браузер не слушает TCP, значит нужен шлюз (proxy) TCP↔WebSocket.

**Фрейминг (в бинарных WS-фреймах):**

```
[ 1 byte flags ] [ 4 bytes conn_id BE ] [ 4 bytes payload_len BE ] [ payload (payload_len bytes) ]
flags: bit0 = 1 => payload сжат (zlib), 0 => нет
conn_id: уникален для TCP-соединения (X11 client connection)
```

* Control сообщения (JSON) идут как *текстовые WS сообщения* (например NEW\_CONN/CLOSE\_CONN/SESSION\_META/HEARTBEAT).
* Binary messages содержат X11 raw bytes, возможно сжатые — клиент распаковывает и напрямую передаёт в JS X-server парсер.

Почему так: простая унификация, мультиплекс через один WS, сжатие совместимо с JS (pako) и Python (zlib).

# 2. Структура репозитория (примерная)

```
x11-over-ws/
├─ server/
│  ├─ proxy.py               # основной Python asyncio TCP<->WS proxy (сжатие zlib)
│  ├─ session_manager.py     # управление сессиями, токенами, xauth (создание cookie)
│  ├─ systemd/
│  │   └─ xoverws@.service
│  └─ requirements.txt
├─ client/
│  ├─ public/
│  │   ├─ index.html         # UI-загрузчик / canvas
│  │   ├─ x11client.js       # JS X-server (форк/адаптация x11server-js)
│  │   └─ vendor/
│  │       └─ pako.min.js    # zlib в браузере
│  └─ README_client.md
├─ docs/
│  ├─ protocol.md
│  ├─ architecture.md
│  └─ runbook.md
├─ tools/
│  ├─ test_x_client.py       # тестовый TCP X-client для отладки proxy
│  └─ gen_xauth_cookie.sh
└─ README.md
```

# 3. Технологии и зависимости

**Сервер (Python):**

* Python 3.12
* виртуальное окружение .venv в папке репозитория
* авторазвертывание 
* `websockets` (async WS) — `pip install websockets`
* `aiohttp` или встроенный `http.server` — для отдачи `public/` (можно nginx)
* `zlib` (в stdlib) — compress/decompress
* опционально: `cryptography` — генерация токенов
* systemd для автозапуска

**Клиент (браузер):**

* Vanilla JS (или React если хочешь SPA)
* `pako` (zlib в браузере) — CDN или локально
* основной X11-парсер/рендер — форк `x11server-js` (адаптация)

# 4. Что делает `proxy.py` (конкретно)

* Поднимает TCP-server на порту `6000 + DISPLAY` (по умолчанию display=99 → 6099). X-клиенты подключаются сюда (через `DISPLAY=127.0.0.1:99`).
* Поднимает WebSocket сервер (например `/display/99`) для браузерного X-сервера.
* Мультиплексирует: каждому входящему TCP-соединению назначает `conn_id` (uint32), и всё что приходит от TCP — упаковывает в бинарный WS-фрейм по указанному формату и шлёт браузеру. Аналогично в обратную сторону.
* Делает **компрессию** payload’ов с помощью `zlib.deflate()` (threshold > N байт, например 64B).
* Управляет сессиями: только один WS может быть «владелец» дисплея; session\_manager создаёт `xauth` cookie для приложений (чтобы только авторизованный клиент мог подключиться).

# 5. Минимальный `proxy.py` — каркас (Python, asyncio)

(в IDE создай `server/proxy.py`). Ниже фрагмент — готовый каркас, который ты сразу сможешь подставить:

```python
# server/proxy.py (урезанный пример)
import asyncio, struct, json, zlib, argparse, logging
import websockets

logging.basicConfig(level=logging.INFO)

FLAG_COMPRESSED = 1

class DisplayProxy:
    def __init__(self, display=99, ws_host='0.0.0.0', ws_port=8080, tcp_host='127.0.0.1'):
        self.display = display
        self.tcp_port = 6000 + display
        self.ws_host = ws_host
        self.ws_port = ws_port
        self.tcp_host = tcp_host
        self.ws = None
        self.next_conn = 1
        self.conns = {}  # conn_id -> writer

    async def ws_handler(self, ws, path):
        # check path etc...
        self.ws = ws
        async for msg in ws:
            if isinstance(msg, str):
                # control
                try:
                    obj = json.loads(msg)
                except:
                    continue
            else:
                # binary: parse frame
                if len(msg) < 9: continue
                flags = msg[0]
                conn_id = struct.unpack('!I', msg[1:5])[0]
                payload_len = struct.unpack('!I', msg[5:9])[0]
                payload = msg[9:9+payload_len]
                if flags & FLAG_COMPRESSED:
                    payload = zlib.decompress(payload)
                writer = self.conns.get(conn_id)
                if writer:
                    writer.write(payload)
                    await writer.drain()

    async def tcp_client(self, reader, writer):
        conn_id = self.next_conn; self.next_conn += 1
        self.conns[conn_id] = writer
        # notify client
        if self.ws:
            await self.ws.send(json.dumps({"type":"NEW_CONN","conn":conn_id}))
        try:
            while True:
                data = await reader.read(8192)
                if not data:
                    break
                # compress if big enough
                flags = 0
                payload = data
                if len(data) > 64:
                    payload = zlib.compress(data)
                    flags = FLAG_COMPRESSED
                frame = struct.pack('!B I I', flags, conn_id, len(payload)) + payload
                if self.ws:
                    await self.ws.send(frame)
        finally:
            # cleanup
            if self.ws:
                await self.ws.send(json.dumps({"type":"CLOSE_CONN","conn":conn_id}))
            writer.close()
            await writer.wait_closed()
            del self.conns[conn_id]

    async def start(self):
        tcp_srv = await asyncio.start_server(self.tcp_client, self.tcp_host, self.tcp_port)
        ws_srv = websockets.serve(self.ws_handler, self.ws_host, self.ws_port, max_size=None)
        async with tcp_srv:
            async with ws_srv:
                await asyncio.Future()

if __name__ == '__main__':
    p = argparse.ArgumentParser(); p.add_argument('--display', type=int, default=99)
    args = p.parse_args()
    proxy = DisplayProxy(display=args.display)
    asyncio.run(proxy.start())
```

> Этот код — каркас. В IDE добавь логирование, обработку ошибок, heartbeat, auth проверки (ниже).

# 6. Клиент: подключение и распаковка (пример client/public/x11client\_stub.js)

* В браузере подключаем pako для распаковки:

```html
<script src="vendor/pako.min.js"></script>
<script>
const ws = new WebSocket("wss://your.server/display/99");
ws.binaryType = 'arraybuffer';
ws.onmessage = (ev) => {
  if (typeof ev.data === 'string') {
    const obj = JSON.parse(ev.data);
    console.log("CTRL", obj);
    return;
  }
  const buf = new Uint8Array(ev.data);
  const flags = buf[0];
  const conn = (buf[1]<<24)|(buf[2]<<16)|(buf[3]<<8)|buf[4];
  const len = (buf[5]<<24)|(buf[6]<<16)|(buf[7]<<8)|buf[8];
  let payload = buf.slice(9, 9+len);
  if (flags & 1) {
    // decompress using pako
    payload = pako.inflate(payload);
  }
  // pass payload bytes to your X11 parser/renderer
  x11_ondata(conn, payload);
};
</script>
```

* `x11_ondata` — функция в `x11client.js` (форк/адаптация x11server-js), она должна принимать сырные X11-байты и парсить их.

# 7. Session management и XAUTH (очень важно)

Чтобы приложения на сервере подключались к нашему proxy, нужно:

* Создать для каждой сессии DISPLAY N (например 99) и сгенерировать XAUTH cookie (MIT-MAGIC-COOKIE-1).
* Запускать приложения (xfce4-session и пр.) с `DISPLAY=127.0.0.1:99` и `XAUTHORITY` указывающим файл с cookie.
* Proxy не занимается аутентификацией X11 — он просто переводит. Но **session\_manager.py** должен хранить (session\_token ↔ display ↔ xauth\_cookie) и проверять, что только авторизованный браузер может подключиться к `/display/99`. При WS соединении проверять JWT/QueryToken и только после этого привязывать ws к дисплею.

# 8. Systemd + запуск XFCE (пример)

* Unit `xoverws@99.service` (см. ранее) запуск proxy.
* Скрипт запуска сессии `start_session.sh`:

```bash
#!/bin/bash
DISPLAY_NUM=99
XAUTH_FILE=/var/run/x11sess/xauth_${DISPLAY_NUM}
mkdir -p /var/run/x11sess
# generate cookie
mcookie > $XAUTH_FILE
export XAUTHORITY=$XAUTH_FILE
export DISPLAY=127.0.0.1:$DISPLAY_NUM
# start xfce (or apps)
xfce4-session &
```

(реально: `mcookie` не создаёт xauth file — используй `xxd` to generate cookie or use `xauth add`).

# 9. Безопасность (обязательные шаги)

* **TLS (wss\://)**: WS через nginx reverse proxy + certbot.
* **Аутентификация**: перед тем как позволить ws привязаться к display, требовать токен (JWT) — browser получает токен после логина. Token ↔ session\_manager.
* **XAUTH cookie**: храним секретно, не передаём в браузере. Proxy только форвардит байты, но не раскрывает cookie.
* **Firewall**: не открывать TCP 6000+ на внешку — только localhost; WS — только через nginx.
* **Логи**: логировать необработанные X11 запросы (важно для разработки).

# 10. План задач/веток в IDE (готовые issues)

Разбей работу на issues:

A. Базовый транспорт

1. `task/proxy-basic` — реализовать proxy.py (строго TCP↔WS, framing, zlib compress). ✅
2. `task/client-stub` — простая client public/index.html+stub, принимает фреймы, распаковывает и логирует. ✅
3. `task/test-client` — tools/test\_x\_client.py эмулирует X-клиента (отправляет данные, проверяет ответ).

B. Сессии и запуск приложений
4\. `task/session-manager` — session\_manager.py: create session, generate xauth, map token→display.
5\. `task/start-session-script` — systemd + start\_session.sh; документация.

C. Клиентский X-сервер (ядро диплома)
6\. `task/x11-js-integration` — форк/интеграция x11server-js в client/public, реализовать x11\_ondata(payload).
7\. `task/rendering-wm` — базовый оконный менеджер (заголовки, stacking, move/resize).
8\. `task/input-backprop` — mouse/keyboard events → send to proxy as binary frames (with conn\_id), map to X events.

D. Оптимизация + безопасность
9\. `task/compression-tuning` — threshold, batch frames, measure.
10\. `task/nginx-wss` — nginx config + certbot + JWT auth.
11\. `task/perf-tests` — compare traffic with VNC/xpra.

E. Документация и защита
12\. `task/docs` — protocol.md, architecture.md, runbook.md
13\. `task/demo-scripts` — demo.sh: start service, open browser, run xterm.

# 11. Тесты и отладка (быстрые рецепты)

* Запуск в IDE: старт proxy, открыть client/index.html, затем на сервере `DISPLAY=127.0.0.1:99 xterm`. Смотри logs в браузере.
* Логировать первые несколько байт X11 init handshake (это даст подсказку что именно приложение шлёт).
* Используй `tcpdump -i lo port 6099 -w dump.pcap` и Wireshark (расшифровка X11) — полезно.
* Логировать неподдерживаемые X11 requests (в клиенте) — по мере запуска XFCE будут появляться отсутствующие opcode — фиксируй приоритетно.

# 12. Ограничения и честный прогноз

* Поддержать **весь** X11 протокол — нереально в срок; нужно ограничить scope: реализовать достаточную подмножину opcodes и ICCCM/EWMH (для WM).
* Некоторые приложения используют XShm/XRender/OpenGL — они потребуют дополнительные мосты/фоллбеки.
* Тестируй с простыми приложениями (xterm, xclock, mousepad), затем MATE/XFCE и фиксируй ошибки по мере поступления.

# 13. Что я могу сгенерировать прямо сейчас (готово к вставке в IDE)

Если хочешь, прямо сейчас я:

* сгенерирую полный файл `server/proxy.py` (более устойчивый, с heartbeat, auth hook и CLI опциями), и
* `client/public/index.html` + `client/public/x11client_stub.js` (логирование + pako decompression), и
* `tools/test_x_client.py` (симулятор X-клиента), и
* шаблон `docs/protocol.md` с примерами фреймов.

Скажи «да — сгенерируй» и я вставлю все эти файлы в ответ одним пакетом, готовым для вставки в проект в IDE.
